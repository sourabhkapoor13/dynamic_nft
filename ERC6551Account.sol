// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.19;

import "./dynamic_nft.sol";
import "./erc20.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
import "@openzeppelin/contracts/interfaces/IERC1271.sol";
import "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";
import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import "./IERC6551Account.sol";
import "./Bytecode.sol";
import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";
import "./MinimalReceiver.sol";
// account=0x4d15998939cc2B2F580076e585A258650d0Fe68D
//registery=0x58DCcaBe23cb81d8728f2A9620A66fe1061fb9Af
//dynamic nft=0xb96dF0c66D0D6Ac3a9ADE69495999A9389A895E9
//erc20=0x662C673f1d9b2B1FC49C7c31358081851fA3e537
//wallet=0x97f41a01c12D83095De8b269f2b9B0F6256cC6Da
// add1=0x5b263606DB932Cb7BAeb6cB3333CE24902dD3816
//add2=0xBBE443E29ad7FB13ab48BFa71C55Ff14231aB568
//0xa5B2aFB4516776De9dABedf7397707fbbAca4cB9
contract Account is
    IERC165,
    IERC1271,
    IERC6551Account,
    MinimalReceiver,
    AutomationCompatibleInterface
{
    Account contract_instance;
    address owners;
    address public allowed;

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (
            bool upkeepNeeded,
            bytes memory /* performData */
        )
    {
        upkeepNeeded = owners != owner();
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    // this is oracle function which will run automatically when offchain data requirment is met

    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        // We highly recommend revalidating the upkeep in the performUpkeep function

        if (owners != owner()) {
            allowed = address(0);
            owners = owner();
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    //transfering ownership
    event alloweduser(address indexed Owner, address indexed allowedUser);

    function set_owner() public {
        owners = owner();
    }

    //Event emitted when an NFT is transferred
    event NFTTransferred(address from, address to, uint256 tokenId);

    // Event emitted when an ERC2O Token is transferred
    event ERC2OTokenTransferred(address from, address to, uint256 tokenId);

    // Event emitted when spender is approved
    event ERC20Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    event ERC721Approval(
        address indexed owner,
        address indexed approved,
        uint256 indexed tokenId
    );

    // Event emitted when ERC1155 tokens are transferred
    event BatchErc1155TokensTransferred(
        address from,
        address to,
        uint256[] tokenIds,
        uint256[] amounts
    );

    event ApprovalForAll(
        address indexed account,
        address indexed operator,
        bool approved
    );

    // Event emitted when an ERC1155 token is transferred
    event ERC1155TokenTransferred(
        address from,
        address to,
        uint256 tokenId,
        uint256 amount
    );

    //receive() external payable {}
    constructor() {
        contract_instance = Account(payable(address(this)));
    }

    function executeCall(
        address to,
        uint256 value,
        bytes calldata data
    ) external payable returns (bytes memory result) {
        require(msg.sender == owner(), "Not token owner");

        bool success;
        (success, result) = to.call{value: value}(data);

        if (!success) {
            assembly {
                revert(add(result, 32), mload(result))
            }
        }
    }

   

    function token()
        external
        view
        returns (
            uint256 chainId,
            address tokenContract,
            uint256 tokenId
        )
        
    {
        uint256 length = address(this).code.length;
        return
            abi.decode(
                Bytecode.codeAt(address(this), length - 0x60, length),
                (uint256, address, uint256)
            );
    }

    modifier onlyOwner() {
        require(msg.sender == owner() || msg.sender == allowed);
        _;
    }

    function owner() public view returns (address) {
        (uint256 chainId, address tokenContract, uint256 tokenId) = this
            .token();
        if (chainId != block.chainid) return address(0);

        return IERC721(tokenContract).ownerOf(tokenId);
    }

    // function supportsInterface(bytes4 interfaceId) public pure returns (bool) {
    //     return (interfaceId == type(IERC165).interfaceId ||
    //         interfaceId == type(IERC6551Account).interfaceId);
    // }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IERC165, ERC1155Receiver)
        returns (bool)
    {
        // default interface support
        if (
            interfaceId == type(IERC6551Account).interfaceId ||
            interfaceId == type(IERC1155Receiver).interfaceId ||
            interfaceId == type(IERC165).interfaceId
        ) {
            return true;
        }

        address _executor = owner();

        if (_executor == address(0) || _executor.code.length == 0) {
            return false;
        }

        // if interface is not supported by default, check executor
        try IERC165(_executor).supportsInterface(interfaceId) returns (
            bool _supportsInterface
        ) {
            return _supportsInterface;
        } catch {
            return false;
        }
    }

    function isValidSignature(bytes32 hash, bytes memory signature)
        external
        view
        returns (bytes4 magicValue)
    {
        bool isValid = SignatureChecker.isValidSignatureNow(
            owner(),
            hash,
            signature
        );

        if (isValid) {
            return IERC1271.isValidSignature.selector;
        }

        return "";
    }

    function allowed_user(address _user) public onlyOwner {
        require(_user != address(0));

        emit alloweduser(owner(), _user);

        allowed = _user;
    }

    function erc20_token_balance(address token_address)
        public
        view
        returns (uint256)
    {
        IERC20 erc20Contract = IERC20(token_address);
        return erc20Contract.balanceOf(address(this));
    }

    function erc721_token_balance(address token_address)
        public
        view
        returns (uint256)
    {
        IERC721 erc721Contract = IERC721(token_address);
        return erc721Contract.balanceOf(address(this));
    }

    function erc1155_token_balance(address token_address, uint256 id)
        public
        view
        returns (uint256)
    {
        IERC1155 erc1155Contract = IERC1155(token_address);
        return erc1155Contract.balanceOf(address(this), id);
    }

    // Transfer an ERC2O Token from this contract to another address
    function transferERC20Tokens(
        address tokenCollection,
        address to,
        uint256 amount
    ) external onlyOwner {
        // Get the instance of the IERC20 contract
        erc20 erc20Contract = erc20(tokenCollection);

        // Check if the owner have required amount of tokens
        require(
            erc20Contract.balanceOf(address(this)) >= amount,
            "Owner dont have sufficient amount of ERC20 tokens"
        );

        // Transfer the tokens to the specified address
        // erc20Contract.approve(address(this), address(this), amount);

        erc20Contract.transfer(
             to,amount
            
        );

        // Emit the ERC2OTokenTransferred event
        emit ERC2OTokenTransferred(address(this), to, amount);
    }

    // Transfer an ERC2O Token to another address (if this wallet address have approval)
    function transferFromERC20Tokens(
        address tokenCollection,
        address from,
        address to,
        uint256 amount
    ) external onlyOwner {
        // Get the instance of the IERC20 contract
        erc20 erc20Contract = erc20(tokenCollection);

        // Check if the owner have required amount of tokens
        require(
            erc20Contract.balanceOf(from) >= amount,
            "Owner dont have sufficient amount of ERC20 tokens"
        );
erc20Contract.approve(address(this), address(this), amount);
        // Transfer the tokens to the specified address
        erc20Contract.transferFrom(from, to, amount);

        // Emit the ERC2OTokenTransferred event
        emit ERC2OTokenTransferred(from, to, amount);
    }

    // Approve another address as spender of my ERC2O Token
    // function ApproveERC20Tokens(
    //     address tokenCollection,
    //     address spender,
    //     uint256 amount
    // ) external onlyOwner {
    //     // Get the instance of the IERC20 contract
    //     IERC20 erc20Contract = IERC20(tokenCollection);

    //     // Check if the owner have required amount of tokens
    //     require(
    //         erc20Contract.balanceOf(address(this)) >= amount,
    //         "Owner dont have sufficient amount of ERC20 tokens"
    //     );

    //     // Transfer the tokens to the specified address
    //     erc20Contract.approve(spender, amount);

    //     // Emit the Approve event
    //     emit ERC20Approval(address(this), spender, amount);
    // }

    // Transfer an NFT from this contract to another address
    function transferERC721Tokens(
        address tokenCollection,
        address to,
        uint256 tokenId
    ) external onlyOwner {
        // Get the instance of the ERC721 contract
        dynamic_mint nftContract = dynamic_mint(tokenCollection);

        // Check if the sender is the current owner of the NFT
        require(
            nftContract.ownerOf(tokenId) == address(this),
            "NFTHandler: Sender is not the owner"
        );

        // Transfer the NFT to the specified address
        nftContract.transfer( to, tokenId);

        // Emit the NFTTransferred event
        emit NFTTransferred(address(this), to, tokenId);
    }

    // Approve spender for your nft
    // function ApproveERC721Tokens(
    //     address tokenCollection,
    //     address spender,
    //     uint256 tokenId
    // ) external onlyOwner {
    //     // Get the instance of the ERC721 contract
    //     IERC721 nftContract = IERC721(tokenCollection);

    //     // Check if the sender is the current owner of the NFT
    //     require(
    //         nftContract.ownerOf(tokenId) == address(this),
    //         "NFTHandler: Sender is not the owner"
    //     );

    //     // Transfer the NFT to the specified address
    //     nftContract.approve(spender, tokenId);

    //     // Emit the ERC721Approval event
    //     emit ERC721Approval(address(this), spender, tokenId);
    // }

    // // Transfer an NFT from on behalf ofowner to another address
    // function transferERC721TokensFrom(
    //     address tokenCollection,
    //     address from,
    //     address to,
    //     uint256 tokenId
    // ) external onlyOwner {
    //     // Get the instance of the ERC721 contract
    //     IERC721 nftContract = IERC721(tokenCollection);

    //     // Check if the sender is the current owner of the NFT
    //     require(
    //         nftContract.getApproved(tokenId) == address(this),
    //         "NFTHandler: Sender is not approved"
    //     );

    //     // Transfer the NFT to the specified address
    //     nftContract.safeTransferFrom(from, to, tokenId);

    //     // Emit the NFTTransferred event
    //     emit NFTTransferred(from, to, tokenId);
    // }

    // Transfer ERC1155 tokens from this contract to another address
    function transferERC1155Tokens(
        address tokenCollection,
        address to,
        uint256 tokenId,
        uint256 amount
    ) external onlyOwner {
        // Get the instance of the ERC1155 contract
        IERC1155 erc1155Contract = IERC1155(tokenCollection);

        // Check if the sender has enough tokens to transfer
        require(
            erc1155Contract.balanceOf(address(this), tokenId) >= amount,
            "ERC1155Handler: Insufficient balance"
        );

        // Transfer the tokens to the specified address
        erc1155Contract.safeTransferFrom(
            address(this),
            to,
            tokenId,
            amount,
            ""
        );

        // Emit the ERC1155TokenTransferred event
        emit ERC1155TokenTransferred(address(this), to, tokenId, amount);
    }

    function setApprovalForAllERC1155(
        address tokenCollection,
        address operator,
        bool approved
    ) external onlyOwner {
        // Get the instance of the ERC1155 contract
        IERC1155 erc1155Contract = IERC1155(tokenCollection);

        // Check if the operator is nit owner
        require(
            operator == address(this),
            "NFTHandler: operator should not be owner"
        );
        // Transfer the tokens to the specified address
        erc1155Contract.setApprovalForAll(operator, approved);

        // Emit the ApprovalForAll event
        emit ApprovalForAll(address(this), operator, approved);
    }

    // Transfer ERC1155 tokens from this contract to another address
    function batchTransferERC1155Tokens(
        address tokenCollection,
        address to,
        uint256[] memory tokenIds,
        uint256[] memory amounts
    ) external onlyOwner {
        require(
            tokenIds.length == amounts.length,
            "ERC1155Handler: Invalid input length"
        );

        // Get the instance of the ERC1155 contract
        IERC1155 erc1155Contract = IERC1155(tokenCollection);

        for (uint256 i = 0; i < tokenIds.length; i++) {
            require(
                erc1155Contract.balanceOf(address(this), tokenIds[i]) >=
                    amounts[i],
                "ERC1155Handler: Insufficient balance"
            );
        }

        // Batch transfer the tokens to the specified address
        erc1155Contract.safeBatchTransferFrom(
            address(this),
            to,
            tokenIds,
            amounts,
            ""
        );

        // Emit the TokensTransferred event
        emit BatchErc1155TokensTransferred(
            address(this),
            to,
            tokenIds,
            amounts
        );
    }
}

[
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_size",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_start",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "_end",
				"type": "uint256"
			}
		],
		"name": "InvalidCodeAtRange",
		"type": "error"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "account",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "bool",
				"name": "approved",
				"type": "bool"
			}
		],
		"name": "ApprovalForAll",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256[]",
				"name": "tokenIds",
				"type": "uint256[]"
			},
			{
				"indexed": false,
				"internalType": "uint256[]",
				"name": "amounts",
				"type": "uint256[]"
			}
		],
		"name": "BatchErc1155TokensTransferred",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "ERC1155TokenTransferred",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "ERC20Approval",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "ERC2OTokenTransferred",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "approved",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "ERC721Approval",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "NFTTransferred",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "Owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "allowedUser",
				"type": "address"
			}
		],
		"name": "alloweduser",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "allowed",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_user",
				"type": "address"
			}
		],
		"name": "allowed_user",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "tokenCollection",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256[]",
				"name": "tokenIds",
				"type": "uint256[]"
			},
			{
				"internalType": "uint256[]",
				"name": "amounts",
				"type": "uint256[]"
			}
		],
		"name": "batchTransferERC1155Tokens",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes",
				"name": "",
				"type": "bytes"
			}
		],
		"name": "checkUpkeep",
		"outputs": [
			{
				"internalType": "bool",
				"name": "upkeepNeeded",
				"type": "bool"
			},
			{
				"internalType": "bytes",
				"name": "",
				"type": "bytes"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token_address",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "id",
				"type": "uint256"
			}
		],
		"name": "erc1155_token_balance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token_address",
				"type": "address"
			}
		],
		"name": "erc20_token_balance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token_address",
				"type": "address"
			}
		],
		"name": "erc721_token_balance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			},
			{
				"internalType": "bytes",
				"name": "data",
				"type": "bytes"
			}
		],
		"name": "executeCall",
		"outputs": [
			{
				"internalType": "bytes",
				"name": "result",
				"type": "bytes"
			}
		],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes32",
				"name": "hash",
				"type": "bytes32"
			},
			{
				"internalType": "bytes",
				"name": "signature",
				"type": "bytes"
			}
		],
		"name": "isValidSignature",
		"outputs": [
			{
				"internalType": "bytes4",
				"name": "magicValue",
				"type": "bytes4"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "uint256[]",
				"name": "",
				"type": "uint256[]"
			},
			{
				"internalType": "uint256[]",
				"name": "",
				"type": "uint256[]"
			},
			{
				"internalType": "bytes",
				"name": "",
				"type": "bytes"
			}
		],
		"name": "onERC1155BatchReceived",
		"outputs": [
			{
				"internalType": "bytes4",
				"name": "",
				"type": "bytes4"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "bytes",
				"name": "",
				"type": "bytes"
			}
		],
		"name": "onERC1155Received",
		"outputs": [
			{
				"internalType": "bytes4",
				"name": "",
				"type": "bytes4"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			},
			{
				"internalType": "bytes",
				"name": "",
				"type": "bytes"
			}
		],
		"name": "onERC721Received",
		"outputs": [
			{
				"internalType": "bytes4",
				"name": "",
				"type": "bytes4"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes",
				"name": "",
				"type": "bytes"
			}
		],
		"name": "performUpkeep",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "tokenCollection",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"internalType": "bool",
				"name": "approved",
				"type": "bool"
			}
		],
		"name": "setApprovalForAllERC1155",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "set_owner",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes4",
				"name": "interfaceId",
				"type": "bytes4"
			}
		],
		"name": "supportsInterface",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "token",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "chainId",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "tokenContract",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "tokenCollection",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "transferERC1155Tokens",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "tokenCollection",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "transferERC20Tokens",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "tokenCollection",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "transferERC721Tokens",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "tokenCollection",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "transferFromERC20Tokens",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"stateMutability": "payable",
		"type": "receive"
	}
]
